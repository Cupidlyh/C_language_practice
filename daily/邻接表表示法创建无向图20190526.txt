//邻接表表示法创建无向图#include<stdio.h>#include<stdlib.h>#define MVNum 100typedef struct arcnode{    int adjvex;    struct arcnode *nextarc;} arcnode;typedef struct vnode{    char data;    arcnode *firstarc;} vnode, adjlist[MVNum];typedef struct{    adjlist vertices;    int vexnum, arcnum;} algraph;int locate(algraph *g,char ch){    int i;    for(i=0; i<g->vexnum; i++)        if(g->vertices[i].data==ch)            return i;}int creat(algraph *g){    int i,j;    printf("请输入总顶点数和总边数:");    scanf("%d %d",&g->vexnum,&g->arcnum);    getchar();    printf("%d %d",g->vexnum,g->arcnum);    printf("\n请输入点的名称\n");    for(j=0; j<g->vexnum; j++)    {        scanf("%c",&g->vertices[j].data);        getchar();        printf("%c\n",g->vertices[j].data);        g->vertices[j].firstarc=NULL;    }    printf("请输入每条边的两个顶点\n");    for(i=0; i<g->arcnum; i++)    {        char v1,v2;        int m,n;        scanf("%c //邻接矩阵创建无向网#include <stdio.h>#include <stdlib.h>#define MaxInt 32767#define MVNum 100typedef struct{    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexnum,arcnum;} amgraph;int locate(amgraph *g,char ch){    int i;    for(i=0; i<g->vexnum; i++)        if(g->vexs[i]==ch)            return i;}int creat(amgraph *g){    int i,j,k;    printf("请输入总顶点数 总边数:");    scanf("%d %d",&g->vexnum,&g->arcnum);    getchar();    printf("%d %d",g->vexnum,g->arcnum);    printf("\n请输入顶点的名称\n");    for(i=0; i<g->vexnum; i++)    {        scanf("%c",&g->vexs[i]);        getchar();        printf("%c",g->vexs[i]);    }    for(i=0; i<g->arcnum; i++)        for(j=0; j<g->arcnum; j++)            g->arcs[i][j]=MaxInt;    printf("\n请输入每条边的两个端点及这两个端点之间的权值\n");    for(k=0; k<g->arcnum; k++)    {        char u1,u2;        int v,m,n;        scanf("%c %c %d",&u1,&u2,&v);        getchar();        printf("%c %c %d\n",u1,u2,v);        m=locate(g,u1);        n=locate(g,u2);        g->arcs[m][n]=v;        g->arcs[n][m]=v;    }    return 1;}int main(){    amgraph g;    int i,j;    freopen("in.txt","r",stdin);    creat(&g);    printf("\n");    for(i = 0 ; i < g.vexnum ; i++)    {        for(j = 0; j < g.vexnum; j++)        {            if(j != g.vexnum - 1)            {                if(g.arcs[i][j] != MaxInt)                    printf("%d  ",g.arcs[i][j]);                else                    printf("∞ ");            }            else            {                if(g.arcs[i][j] != MaxInt)                    printf("%d\n",g.arcs[i][j]);                else                    printf("∞\n");            }        }    }    return 0;}%c",&v1,&v2);        getchar();        printf("%c %c\n",v1,v2);        m=locate(g,v1);        n=locate(g,v2);        arcnode *p1=(arcnode *)malloc(sizeof(arcnode));        p1->adjvex=n;        p1->nextarc=g->vertices[m].firstarc;        g->vertices[m].firstarc=p1;        arcnode *p2=(arcnode *)malloc(sizeof(arcnode));        p2->adjvex=m;        p2->nextarc=g->vertices[n].firstarc;        g->vertices[n].firstarc=p2;    }    return 1;}int main(){    freopen("in.txt","r",stdin);    algraph g;    creat(&g);    int i;    printf("\n");    for(i = 0 ; i < g.vexnum ; i++)    {        vnode temp = g.vertices[i];        arcnode *p = temp.firstarc;        if(p == NULL)        {            printf("%c\n",g.vertices[i].data);        }        else        {            printf("%c",temp.data);            while(p)            {                printf("->");                printf("%d",p->adjvex);                p = p->nextarc;            }        }        printf("\n");    }    return 0;}